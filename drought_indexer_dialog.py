# -*- coding: utf-8 -*-
"""
/***************************************************************************
 droughtIndexerDialog
                                 A QGIS plugin
 A plugin to Process Standardized Agricultural Drought Index.
 Generated by Plugin Builder: http://g-sherman.github.io/Qgis-Plugin-Builder/
                             -------------------
        begin                : 2024-03-03
        git sha              : $Format:%H$
        copyright            : (C) 2024 by John Ngugi
        email                : johnngugi0407@gmail.com
 ***************************************************************************/

/***************************************************************************
 *                                                                         *
 *   This program is free software; you can redistribute it and/or modify  *
 *   it under the terms of the GNU General Public License as published by  *
 *   the Free Software Foundation; either version 2 of the License, or     *
 *   (at your option) any later version.                                   *
 *                                                                         *
 ***************************************************************************/
"""

import os

from qgis.PyQt import uic
from qgis.PyQt import QtWidgets
from qgis.utils import active_plugins

import time


# This loads your .ui file so that PyQt can populate your plugin with the elements from Qt Designer
FORM_CLASS, _ = uic.loadUiType(os.path.join(
    os.path.dirname(__file__), 'drought_indexer_dialog_base.ui'))


class droughtIndexerDialog(QtWidgets.QDialog, FORM_CLASS):
    def __init__(self, parent=None):
        """Constructor."""
        super(droughtIndexerDialog, self).__init__(parent)
        # Set up the user interface from Designer through FORM_CLASS.
        # After self.setupUi() you can access any designer object by doing
        # self.<objectname>, and you can use autoconnect slots - see
        # http://qt-project.org/doc/qt-4.8/designer-using-a-ui-file.html
        # #widgets-and-dialogs-with-auto-connect
        self.setupUi(self)

        self.okBtn.accepted.connect(self.showValue)
        

    def isPluginEnabled(self,plugin_name):
            plugins = active_plugins
            plugin_status = None
            # Check if the plugin is enabled
            if plugin_name in plugins:
                plugin_status = True
            else: 
                plugin_status = False    
            
            return plugin_status

    def showValue(self):

        # Check if the required plugin is enabled
        plugin_status  = self.isPluginEnabled('ee_plugin')
        if plugin_status != True:
            # Plugin is not enabled, show an error message and return
            QtWidgets.QMessageBox.warning(self, "Plugin Error", "The required plugin is not enabled.\n please install the Google Earth Engine plugin and try again")
            return
        
        import ee 
        from ee_plugin import Map
        xmin = self.sbXmin.value()
        xmax = self.sbXmax.value() 

        ymax = self.sbYmax.value()
        ymin = self.sbYmin.value()
        

        xmax_right = self.sbXmaxr.value()
        xmin_right = self.sbXminr.value()

        ymax_right = self.sbYmaxr.value()
        ymin_right = self.sbYminr.value()

        ROI1=ee.FeatureCollection('users/muthamijohn/kwanza_constituency')

        if xmax and ymax and xmax_right and ymax_right and xmin_right and ymin_right and xmin and ymin:
            ROI1=ee.Geometry.Polygon([[xmax,ymax],[xmax_right,ymax_right],[xmin_right,ymin_right],[xmin,ymin],])
        
        Map.centerObject(ROI1, 12)
        start_year = int( self.startDate.currentText())
        end_year = int(self.endDate.currentText())
        season = str(self.season.value())
        print(season)
        
        geometry = ROI1
        if season=='1':
            startmonth = 1
            endmonth = 3
        elif season == '2':
            startmonth = 4
            endmonth = 6
        elif season =='3':
            startmonth =7
            endmonth = 9
        elif season == '4':
            startmonth = 10
            endmonth = 12
        else:
            print(" no season lioke that exists ")

        images = []

        
        def maskS2clouds(image):
            return image.updateMask(image.select('QA60').eq(0))


        def calculate_drought_index(start_year, end_year,startmonth,endmonth):
            
                # Cloud mask
            # Cloud mask
                def maskL5(col):
                        # Bits 3 and 5 are cloud shadow and cloud, respectively.
                        cloudShadowBitMask = (1 << 3)
                        cloudsBitMask = (1 << 5)

                        # Get the pixel QA band.
                        qa = col.select('QA_PIXEL')

                        # Both flags should be set to zero, indicating clear conditions.
                        mask = qa.bitwiseAnd(cloudShadowBitMask).eq(0) \
                        .And(qa.bitwiseAnd(cloudsBitMask).eq(0))

                        return col.updateMask(mask)

                # Load the collection
                col = ee.ImageCollection("LANDSAT/LE07/C02/T1") \
                        .map(maskL5) \
                        .filter(ee.Filter.calendarRange(start_year, end_year, 'year')) \
                        .filter(ee.Filter.calendarRange(startmonth,endmonth, 'month'))\
                        .filterBounds(geometry)

                col1 = col.mean().clip(geometry)

                # Image reduction
                image = col.mean()

                # Calculate TOA spectral radiance
                ML = 0.055375
                AL = 1.18243
                TOA_radiance = image.expression('ML * B6 + AL', {
                        'ML': ML,
                        'AL': AL,
                        'B6': image.select('B6_VCID_1')
                })

                # Convert TOA spectral radiance to brightness temperature
                K1 = 607.76
                K2 = 1260.56
                brightnessTemp = TOA_radiance.expression(
                        '(K2 / (log((K1 / L) + 1))) - 273.15', {
                        'K1': K1,
                        'K2': K2,
                        'L': TOA_radiance
                        })


                clippedbrightnessTemp = brightnessTemp.clip(geometry)

                # Median
                ndvi = image.normalizedDifference(['B4', 'B3']).rename('NDVI')
                NDVI_IMAGE = ndvi.clip(geometry)

                # Find the min and max of NDVI
                min_val = ndvi.reduceRegion(ee.Reducer.min(), geometry, 30, maxPixels=1e9).get('NDVI')
                max_val = ndvi.reduceRegion(ee.Reducer.max(), geometry, 30, maxPixels=1e9).get('NDVI')
                min_value = ee.Number(min_val)
                max_value = ee.Number(max_val)

                # Fractional vegetation
                fv = ndvi.subtract(min_value).divide(max_value.subtract(min_value)).pow(2).rename('FV')
                VCI = (ndvi.subtract(min_value)).divide(max_value.subtract(min_value))

                # Emissivity
                a = ee.Number(0.004)
                b = ee.Number(0.986)
                EM = fv.multiply(a).add(b).rename('EMM')

                # Calculate land surface temperature
                landSurfaceTemp = brightnessTemp.expression(
                        '(BT / (1 + (10.60 * BT / 14388) * log(epsilon)))', {
                        'BT': brightnessTemp,
                        'epsilon': EM.select('EMM')
                        })

                # Clip the land surface temperature image to the geometry
                clippedLandSurfaceTemp = landSurfaceTemp.clip(geometry)

                # Find the min and max of LST
                min_v = clippedLandSurfaceTemp.reduceRegion(ee.Reducer.min(), geometry, 30, maxPixels=1e9).values().get(0)
                max_v = clippedLandSurfaceTemp.reduceRegion(ee.Reducer.max(), geometry, 30, maxPixels=1e9).values().get(0)
                min_LST = ee.Number(min_v)
                max_LST = ee.Number(max_v)

                max_LST_1 = ee.Image(max_LST)
                #Obtain TCI
                TCI = max_LST_1.subtract(clippedLandSurfaceTemp).divide(max_LST.subtract(min_LST))

                #Calculate VCI
                VHI = (VCI.multiply(0.5)).add(TCI.multiply(0.5))

                # VHI classification into classes based on threshold values to calculate Drought Index
                image02 = VHI.lt(0.1).And(VHI.gte(-1))
                image04 = ((VHI.gte(0.1)).And(VHI.lt(0.2))).multiply(2)
                image06 = ((VHI.gte(0.2)).And(VHI.lt(0.3))).multiply(3)
                image08 = ((VHI.gte(0.3)).And(VHI.lt(0.4))).multiply(4)
                image10 = (VHI.gte(0.4)).multiply(5)
                Drought_Index = (image02.add(image04).add(image06).add(image08).add(image10))

                Drought_index_sd_image = Drought_Index.expression('(2*((Drought_Index - min_DI)/(max_DI - min_DI)) -1)',{
                    'Drought_Index': Drought_Index,
                    'min_DI' : ee.Number(Drought_Index.reduceRegion(ee.Reducer.min(), geometry, 30, maxPixels=1e9).values().get(0)),
                    'max_DI' :ee.Number(Drought_Index.reduceRegion(ee.Reducer.max(), geometry, 30, maxPixels=1e9).values().get(0)),

                })



                images.append(Drought_index_sd_image)
                images.append(Drought_Index)
                min_value_DI = Drought_Index.reduceRegion(ee.Reducer.min(), geometry, 30, maxPixels=1e9).values().get(0)
                max_value_DI = Drought_Index.reduceRegion(ee.Reducer.max(), geometry, 30, maxPixels=1e9).values().get(0)
                print(max_value_DI.getInfo())
                print(min_value_DI.getInfo())
                min_value = Drought_index_sd_image.reduceRegion(ee.Reducer.min(), geometry, 30, maxPixels=1e9).values().get(0)
                max_value = Drought_index_sd_image.reduceRegion(ee.Reducer.max(), geometry, 30, maxPixels=1e9).values().get(0)
                print(max_value.getInfo())
                print(min_value.getInfo())
                for i in range(100):
                    # Simulate some processing
                    time.sleep(0.1)
                    progress =int( (i + 1) / 100 * 100)
                    print("Progress:", progress)
                    # Update progress bar value
                    self.progressBar.setValue(progress)
                return Drought_index_sd_image
        
        calculate_drought_index(start_year, end_year,startmonth,endmonth)    


        Map.addLayer(images[0],{'min':-1,'max':1,'palette':['#ec0000','#ecca00','#ec9b00','#ec5300','#ec2400']},'Drought index standardized image')
    

            
        S2 = ee.ImageCollection('COPERNICUS/S2').filter(ee.Filter.calendarRange(2017,2021, 'year')).filter(ee.Filter.calendarRange(4, 7, 'month')).map(maskS2clouds).filter(ee.Filter.lt('CLOUDY_PIXEL_PERCENTAGE', 5)).filterBounds(ROI1)

        Map.addLayer(S2.median().select('B4','B3','B2'),{'min':0,'max':3000, },'satellite image')

        image = S2.median()

        # Compute NDVI
        ndvi = image.normalizedDifference(['B8', 'B4']).rename('NDVI')
        indecesVis = {'min': -1 ,"max": 1, 'palette': ['red','yellow','green']}
        image = image.addBands([ndvi])
        Map.addLayer(image.select('NDVI'),indecesVis,"NDVI")



        if xmin > 0:
            print(xmin)
